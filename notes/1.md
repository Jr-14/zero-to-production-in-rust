# Chapter 1 Notes
- Inner development loop:
  - 1. Make a change
  - 2. compile the application;
  - 3. run tests;
  - 4. run the application
  - 5. go back to 1
- The faster the inner development loop, the quicker the number of iterations that you can complete in a unit of time
- A sizeable chunk of time is spent in the linking phase - assembling the actual binary given the outputs of the earlier compilation stages.
- Default linker is okay, but there are faster alternatives depending on the OS.
  - `lld` on Windows and Linux
  - `zld` on MacOS
- [mold](https://github.com/rui314/mold) is one of the most recent linkers and is supposedly quicker than lld.
- Can also reduce the perceived compilation time - i.e. the time you spend looking at your terminal waiting for `cargo check` or `cargo run`.
  - `cargo install cargo-watch`
  - `cargo-watch` monitors your source code to trigger commands every time a file changes.
- `cargo-watch` supports command chaining as well:
  - `cargo watch -x check -x test -x run
- Tests in CI pipeline can be run using `cargo test`
- Code coverage as a quality check has several drawbacks and does not guarantee correctness of the running application.
- We can measure code coverage of a Rust project by installing `tarpaulin` via `cargo install cargo-tarpauling`.
- We can compute code coverage whilst ignoring test functions via `cargo tarpaulin --ignore-tests`